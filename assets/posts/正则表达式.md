---
authorName: Yu
title: 正则表达式
authorName: Yu
date: 2020-07-29 13:57:22
categories: 正则
tags: 正则表达式
---
### 修饰符
---
| 修饰符 | 含义 | 描述 |
| ----- | ---  | --- |
| i | ignore - 不区分大小写 | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。|
| g | global - 全局匹配 | 查找所有的匹配项。 |
| m | multi line - 多行匹配 | 使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
| s | 特殊字符圆点 . 中包含换行符 \n | 默认情况下的圆点 . 是 匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。 |

```bash
var str="google\nrunoob\ntaobao";
var n1=str.match(/google./);   // 没有使用 s，无法匹配\n
var n2=str.match(/runoob./s);  // 使用 s，匹配\n
```

### 元字符
---
`\ba\w*\b`匹配以字母a开头的单词——先是某个单词开始处(`\b`)，然后是字母a,然后是任意数量的字母或数字(`\w*`)，最后是单词结束处(`\b`)。

`\d+`匹配1个或更多连续的数字。这里的`+`是和`*`类似的元字符，不同的是`*`匹配重复任意次(可能是0次)，而`+`则匹配重复1次或更多次。

`\b\w{6}\b` 匹配刚好6个字符的单词。

| 代码 | 说明 |
| ---- | ---- |
| `.` |	匹配除换行符以外的任意字符 |
| `\w` | 匹配字母或数字或下划线或汉字 |
| `\s` | 匹配任意的空白符 |
| `\d` | 匹配数字 |
| `\b` | 匹配单词的开始或结束 |
| `^` | 匹配字符串的开始 |
| `$` | 匹配字符串的结束 |

<!-- more -->

### 重复
---
你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：

| 代码/语法 | 说明 |
| ---- | ---- |
| `*` |	重复零次或更多次 |
| `+` | 重复一次或更多次 |
| `?` | 重复零次或一次 |
| `{n}` | 重复n次 |
| `{n,}` | 重复n次或更多次 |
| `{n,m}` | 重复n到m次 |

### 字符类
---
要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。

我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。

下面是一个更复杂的表达式：\(?0\d{2}[) -]?\d{8}。

这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。
### 分枝条件
---
`x|y`
### 反义
有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：

| 代码/语法 | 说明 |
| ---- | ---- |
| `\W` | 匹配任意不是字母，数字，下划线，汉字的字符 |
| `\S` | 匹配任意不是空白符的字符 |
| `\D` | 匹配任意非数字的字符 |
| `\B` | 匹配不是单词开头或结束的位置 |
| `[^x]` | 匹配除了x以外的任意字符 |
| `[^aeiou]` | 匹配除了aeiou这几个字母以外的任意字符 |

### 后向引用
---
使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

后向引用用于重复搜索前面某个分组匹配的文本。例如，`\1`代表分组1匹配的文本。难以理解？请看示例：

`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(`\b(\w+)\b`)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(`\s+`)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(`\1`)。

你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(`?<Word>\w+`)(或者把尖括号换成'也行：(`?'Word'\w+`)),这样就把`\w+`的组名指定为`Word`了。要反向引用这个分组捕获的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`。

使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：
表4.常用分组语法

| 分类 | 代码/语法 | 说明 |
| ---- | ---- | ---- |
| 捕获 | `(exp)` | 匹配exp,并捕获文本到自动命名的组里 |
|     | `(?<name>exp)` | 匹配exp,并捕获文本到名称为name的组里，也可以写成`(?'name'exp)` |
|     | `(?:exp)` | 匹配exp,不捕获匹配的文本，也不给此分组分配组号 |
| 零宽断言  | `(?=exp)` | 匹配exp前面的位置 |
|         | `(?<=exp)` | 匹配exp后面的位置 |
|         | `(?!exp)` | 匹配后面跟的不是exp的位置 |
|         | `(?<!exp)` | 匹配前面不是exp的位置 |
| 注释 | `(?#comment)` | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

### 零宽断言
---
接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像`\b`,`^`,`$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：
`(?=exp)`也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。

`(?<=exp)`也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。

假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：`(?<=\d)\d{3})+\b`，用它对1234567890进行查找时结果是234567890。

下面这个例子同时使用了这两种断言：`(?<=\s)\d+(?=\s)`匹配以空白符间隔的数字(再次强调，不包括这些空白符)。
### 负向零宽断言
---
前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：

`\b\w*q[^u]\w*\b`匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为`[^u]`总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的`[^u]`将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的`\w*\b`将会匹配下一个单词，于是`\b\w*q[^u]\w*\b`就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：`\b\w*q(?!u)\w*\b`。

零宽度负预测先行断言`(?!exp)`，断言此位置的后面不能匹配表达式exp。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。

同理，我们可以用(?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。

一个更复杂的例子：(?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。
### 贪婪与懒惰
---
当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

`a.*?b`匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

| 代码/语法 | 说明 |
| ---- | ---- |
| `*?` | 重复任意次，但尽可能少重复 |
| `+?` | 重复1次或更多次，但尽可能少重复 |
| `??` | 重复0次或1次，但尽可能少重复 |
| `{n,m}?` | 重复n到m次，但尽可能少重复 |
| `{n,}?` | 重复n次以上，但尽可能少重复 |

eg: 
```js
let content = '<span style="font-size: 14px; font-family: Microsoft YaHei,sans-serif;">尊敬的<u><strong> ${Candidate_name} </strong><${Candidate_mobile_phone}';
content.replace(/\${(.*?)}/g, function(match, paramKey) {
    console.log(match, paramKey) 
    /** 
     * 懒惰匹配
     * ${Candidate_name} Candidate_name
     * ${Candidate_mobile_phone} Candidate_mobile_phone
    **/
})

```
### replace
---
replace() 方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。
模式可以是一个字符串或者一个正则表达式.
替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。如果pattern是字符串，则仅替换第一个匹配项。
```js
let content = 'dfsfsdo dsfsDo wodogrd';
content.replace('do', 'YU'); // 返回个新字符串"dfsfsYU dsfsDo wodogrd"
content.replace(/do/gi, 'YU'); // "dfsfsYU dsfsYU woYUrd"

// 交换字符串中的两个单词
var re = /(\w+)\s(\w+)/;
var str = "John Smith";
var newstr = str.replace(re, "$2, $1");
// Smith, John
```
参数使函数时

| 变量名 | 代表的值 |
| ----- | ------- |
| match | 匹配的子串。（对应于上述的$&。）|
| p1,p2, ... | 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如，如果是用 /(\a+)(\b+)/ 这个来匹配，p1 就是匹配的 \a+，p2 就是匹配的 \b+。 |
| offset | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是 'abcd'，匹配到的子字符串是 'bc'，那么这个参数将会是 1） |
| string | 被匹配的原字符串。|
| NamedCaptureGroup | 命名捕获组匹配的对象 |

```js
function replacer(match, p1, p2, p3, offset, string) {
  // p1 is nondigits, p2 digits, and p3 non-alphanumerics
  return [p1, p2, p3].join(' - ');
}
var newString = 'abc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
console.log(newString);  // abc - 12345 - #$*%
// <hr><p>title: ddd</p> name: yu<hr>获取hr中间的字符,匹配title: d字符串生成obj
mdContent = mdContent.replace(/^<hr>(.*?)<hr>/gis, function (match, p1) {
            p1.replace(/(\w*): (.*?)</gis, function (mah, i1, i2) {
                titleInfo[i1] = i2
            })
            return ''
    }) // 修饰符s使.可以匹配\n换行符
```

### match
---
检索返回一个字符串匹配正则表达式的结果。
- 如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。
- 如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。
附加属性
如上所述，匹配的结果包含如下所述的附加特性。
- groups: 一个捕获组数组 或 undefined（如果没有定义命名捕获组）。
- index: 匹配的结果的开始位置
- input: 搜索的字符串.
一个Array，其内容取决于global（g）标志的存在与否，如果未找到匹配则为null。

```js
var str = 'For more information, see Chapter 3.4.5.1';
var re = /see (chapter \d+(\.\d)*)/i;
var found = str.match(re);
console.log(found);
// logs [ 'see Chapter 3.4.5.1',
//        'Chapter 3.4.5.1',
//        '.1',
//        index: 22,
//        input: 'For more information, see Chapter 3.4.5.1' ]

// 'see Chapter 3.4.5.1' 是整个匹配。
// 'Chapter 3.4.5.1' 被'(chapter \d+(\.\d)*)'捕获。
// '.1' 是被'(\.\d)'捕获的最后一个值。
// 'index' 属性(22) 是整个匹配从零开始的索引。
// 'input' 属性是被解析的原始字符串。
```

下例展示了 match 使用 global 和 ignore case 标志。A-E、a-e 的所有字母将会作为一个数组的元素返回。

```js
var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var regexp = /[A-E]/gi;
var matches_array = str.match(regexp);
console.log(matches_array);
// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']
```

### test
---
test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false.
如果正则表达式设置了全局标志，test() 的执行会改变正则表达式   lastIndex属性。连续的执行test()方法，后续的执行将会从 lastIndex 处开始匹配字符串，(exec() 同样改变正则本身的 lastIndex属性值).
```js
var regex = /foo/g;

// regex.lastIndex is at 0
regex.test('foo'); // true

// regex.lastIndex is now at 3
regex.test('foo'); // false
```
### 应用
---

```js
```

### 相关链接
---
[正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm)
