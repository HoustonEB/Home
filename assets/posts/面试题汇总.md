---
authorName: Yu
title: 面试题汇总
date: 2021-02-19 11:25:01
categories: 面试题汇总
tags: 面试题汇总
---

## 数组扁平化
---

`const arr = [1, [2, [3, [4, 5]]], 6];`
### 1.flat

```js
const res = arr.flat(Infinity);
```
### 2.正则

```js
const res = JSON.stringify([1, [2, [3, [4, 5]]], 6]).replace(/\[|\]/g, '').split(',');
```
{% note warning %}
但是数据类型都会变为字符串
{% endnote %}
### 3.正则改良版

```js
const res = JSON.parse('[' + JSON.stringify(arr).replace(/\[|\]/g, '') + ']');
```
### 4.使用reduce

```js
const flatten = arr => {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, [])
}
const res = flatten(arr);

```
### 5.函数递归

```js
const res = [];
const fn = arr => {
    for(let i = 0; i < arr.length; i++) {
        if(Array.isArray(arr[i])) {
            fn(arr[i]);
        } else {
            res.push(arr[i]);
        }
    }
}
fn(arr);
```
## 数组去重
---

`const arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];`

### 1.利用Set

```js
let res = Array.from(new Set(arr));
```
### 2.两层for循环+splice

```js
let arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];
let unique = arr => {
    let len = arr.length;
    for(let i = 0; i < len; i++) {
        for(let j = i + 1; j <len; j++) {
            if(arr[i] === arr[j]) {
                arr.splice(j, 1);
                // 每删除一个数，j--保证j的值经过自加后不变。同时，len--，减少循环次数提升性能
                len--;
                j--;
            }
        }
    }
    return arr;
}
unique(arr);
```

### 3.利用indexOf

```js
let arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];
let unique = arr => {
    let res = [];
    for(let i = 0; i < arr.length; i++) {
        if(res.indexOf(arr[i]) <= -1) {
            res.push(arr[i]);
        }
    }
    return res;
}
unique(arr);
```
当然也可以用include,filter,思路大同小异.
### 4.利用include

```js
let unique = arr => {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (!res.includes(arr[i])) res.push(arr[i]);
  }
  return res;
}
```
### 5.利用filter

```javascript
let unique = arr => {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index;
  });
}
```
### 6.利用Map

```js
let unique = arr => {
  const map = new Map();
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (!map.has(arr[i])) {
      map.set(arr[i], true);
      res.push(arr[i]);
    }
  }
  return res;
}
```

## 类数组转化为数组
---

类数组是具有length属性,但不具有数组原型上的方法.常见的类数组有arguments,DOM操作方法返回的结果.
### 1.Array.from

```js
Array.from(document.querySelectorAll('div'));
```

### 2.Array.prototype.slice.call()

```js
Array.prototype.slice.call(document.querySelectorAll('div'));
```

### 3.扩展运算符

```js
[...document.querySelectorAll('div')];
```

### 4.利用concat

```js
Array.prototype.concat.apply([], document.querySelectorAll('div'));
```

## Array.prototype.filter()
---

```js
Array.prototype.filter = function(callback, thisArg) {
  if (this == undefined) {
    throw new TypeError('this is null or not undefined');
  }
  if (typeof callback !== 'function') {
    throw new TypeError(callback + 'is not a function');
  }
  const res = [];
  // 让O成为回调函数的对象传递（强制转换对象）
  const O = Object(this);
  // >>>0 保证len为number，且为正整数
  const len = O.length >>> 0;
  for (let i = 0; i < len; i++) {
    // 检查i是否在O的属性（会检查原型链）
    if (i in O) {
      // 回调函数调用传参
      if (callback.call(thisArg, O[i], i, O)) {
        res.push(O[i]);
      }
    }
  }
  return res;
}
```
对于`>>>0`有疑问的: [解释>>>0的作用](https://zhuanlan.zhihu.com/p/100790268)
## Array.prototype.map()
---

```js
Array.prototype.map = function(callback, thisArg) {
  if (this == undefined) {
    throw new TypeError('this is null or not defined');
  }
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  const res = [];
  // 同理
  const O = Object(this);
  const len = O.length >>> 0;
  for (let i = 0; i < len; i++) {
    if (i in O) {
      // 调用回调函数并传入新数组
      res[i] = callback.call(thisArg, O[i], i, this);
    }
  }
  return res;
}
```

## Array.prototype.forEach()
---
`forEach`跟`map`类似,唯一不同的是`forEach`是没有返回值的.
```js
Array.prototype.forEach = function(callback, thisArg) {
  if (this == null) {
    throw new TypeError('this is null or not defined');
  }
  if (typeof callback !== "function") {
    throw new TypeError(callback + ' is not a function');
  }
  const O = Object(this);
  const len = O.length >>> 0;
  let k = 0;
  while (k < len) {
    if (k in O) {
      callback.call(thisArg, O[k], k, O);
    }
    k++;
  }
}
```

## Array.prototype.reduce()
---
```js
Array.prototype.reduce = function(callback, initialValue) {
  if (this == undefined) {
    throw new TypeError('this is null or not defined');
  }
  if (typeof callback !== 'function') {
    throw new TypeError(callbackfn + ' is not a function');
  }
  const O = Object(this);
  const len = this.length >>> 0;
  let accumulator = initialValue;
  let k = 0;
  // 如果第二个参数为undefined的情况下
  // 则数组的第一个有效值作为累加器的初始值
  if (accumulator === undefined) {
    while (k < len && !(k in O)) {
      k++;
    }
    // 如果超出数组界限还没有找到累加器的初始值，则TypeError
    if (k >= len) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    accumulator = O[k++];
  }
  while (k < len) {
    if (k in O) {
      accumulator = callback.call(undefined, accumulator, O[k], k, O);
    }
    k++;
  }
  return accumulator;
}
```

## Function.prototype.apply()
---
第一个参数是绑定的this,默认为`window`,第二个参数是数组或类数组.
```js
Function.prototype.apply = function(context = window, args) {
  if (typeof this !== 'function') {
    throw new TypeError('Type Error');
  }
  const fn = Symbol('fn');
  context[fn] = this;

  const res = context[fn](...args);
  delete context[fn];
  return res;
}
```

## Function.prototype.call()
---
于`call`唯一不同的是,`call()`方法接受的是一个参数列表.
```js
Function.prototype.call = function(context = window, ...args) {
  if (typeof this !== 'function') {
    throw new TypeError('Type Error');
  }
  const fn = Symbol('fn');
  context[fn] = this;

  const res = context[fn](...args);
  delete context[fn];
  return res;
}
```

## Function.prototype.bind()
---

```js
Function.prototype.bind = function(context, ...args) {
  if (typeof this !== 'function') {
    throw new Error("Type Error");
  }
  // 保存this的值
  var self = this;

  return function F() {
    // 考虑new的情况
    if(this instanceof F) {
      return new self(...args, ...arguments)
    }
    return self.apply(context, [...args, ...arguments])
  }
}
```

## jsonp
---

```js
```
