---
authorName: Yu
title: 面试题汇总
date: 2021-02-19 11:25:01
categories: 面试题汇总
tags: 面试题汇总
---

## 数组扁平化
---

`const arr = [1, [2, [3, [4, 5]]], 6];`
### 1.flat

```js
const res = arr.flat(Infinity);
```
### 2.正则

```js
const res = JSON.stringify([1, [2, [3, [4, 5]]], 6]).replace(/\[|\]/g, '').split(',');
```
{% note warning %}
但是数据类型都会变为字符串
{% endnote %}
### 3.正则改良版

```js
const res = JSON.parse('[' + JSON.stringify(arr).replace(/\[|\]/g, '') + ']');
```
### 4.使用reduce

```js
const flatten = arr => {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, [])
}
const res = flatten(arr);

```
### 5.函数递归

```js
const res = [];
const fn = arr => {
    for(let i = 0; i < arr.length; i++) {
        if(Array.isArray(arr[i])) {
            fn(arr[i]);
        } else {
            res.push(arr[i]);
        }
    }
}
fn(arr);
```
## 数组去重
---

`const arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];`

### 1.利用Set

```js
let res = Array.from(new Set(arr));
```
### 2.两层for循环+splice

```js
let arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];
let unique = arr => {
    let len = arr.length;
    for(let i = 0; i < len; i++) {
        for(let j = i + 1; j <len; j++) {
            if(arr[i] === arr[j]) {
                arr.splice(j, 1);
                // 每删除一个数，j--保证j的值经过自加后不变。同时，len--，减少循环次数提升性能
                len--;
                j--;
            }
        }
    }
    return arr;
}
unique(arr);
```

### 3.利用indexOf

```js
let arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];
let unique = arr => {
    let res = [];
    for(let i = 0; i < arr.length; i++) {
        if(res.indexOf(arr[i]) <= -1) {
            res.push(arr[i]);
        }
    }
    return res;
}
unique(arr);
```
当然也可以用include,filter,思路大同小异.
### 4.利用include

```js
let unique = arr => {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (!res.includes(arr[i])) res.push(arr[i]);
  }
  return res;
}
```
### 5.利用filter

```javascript
let unique = arr => {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index;
  });
}
```
### 6.利用Map

```js
let unique = arr => {
  const map = new Map();
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (!map.has(arr[i])) {
      map.set(arr[i], true);
      res.push(arr[i]);
    }
  }
  return res;
}
```

## 类数组转化为数组
---

类数组是具有length属性,但不具有数组原型上的方法.常见的类数组有arguments,DOM操作方法返回的结果.
### 1.Array.from

```js
Array.from(document.querySelectorAll('div'));
```

### 2.Array.prototype.slice.call()

```js
Array.prototype.slice.call(document.querySelectorAll('div'));
```

### 3.扩展运算符

```js
[...document.querySelectorAll('div')];
```

### 4.利用concat

```js
Array.prototype.concat.apply([], document.querySelectorAll('div'));
```

## Array.prototype.filter()
---

```js
Array.prototype.filter = function(callback, thisArg) {
  if (this == undefined) {
    throw new TypeError('this is null or not undefined');
  }
  if (typeof callback !== 'function') {
    throw new TypeError(callback + 'is not a function');
  }
  const res = [];
  // 让O成为回调函数的对象传递（强制转换对象）
  const O = Object(this);
  // >>>0 保证len为number，且为正整数
  const len = O.length >>> 0;
  for (let i = 0; i < len; i++) {
    // 检查i是否在O的属性（会检查原型链）
    if (i in O) {
      // 回调函数调用传参
      if (callback.call(thisArg, O[i], i, O)) {
        res.push(O[i]);
      }
    }
  }
  return res;
}
```
对于`>>>0`有疑问的: [解释>>>0的作用](https://zhuanlan.zhihu.com/p/100790268)
## Array.prototype.map()
---

```js
Array.prototype.map = function(callback, thisArg) {
  if (this == undefined) {
    throw new TypeError('this is null or not defined');
  }
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  const res = [];
  // 同理
  const O = Object(this);
  const len = O.length >>> 0;
  for (let i = 0; i < len; i++) {
    if (i in O) {
      // 调用回调函数并传入新数组
      res[i] = callback.call(thisArg, O[i], i, this);
    }
  }
  return res;
}
```

## Array.prototype.forEach()
---
`forEach`跟`map`类似,唯一不同的是`forEach`是没有返回值的.
```js
Array.prototype.forEach = function(callback, thisArg) {
  if (this == null) {
    throw new TypeError('this is null or not defined');
  }
  if (typeof callback !== "function") {
    throw new TypeError(callback + ' is not a function');
  }
  const O = Object(this);
  const len = O.length >>> 0;
  let k = 0;
  while (k < len) {
    if (k in O) {
      callback.call(thisArg, O[k], k, O);
    }
    k++;
  }
}
```

## Array.prototype.reduce()
---
```js
Array.prototype.reduce = function(callback, initialValue) {
  if (this == undefined) {
    throw new TypeError('this is null or not defined');
  }
  if (typeof callback !== 'function') {
    throw new TypeError(callbackfn + ' is not a function');
  }
  const O = Object(this);
  const len = this.length >>> 0;
  let accumulator = initialValue;
  let k = 0;
  // 如果第二个参数为undefined的情况下
  // 则数组的第一个有效值作为累加器的初始值
  if (accumulator === undefined) {
    while (k < len && !(k in O)) {
      k++;
    }
    // 如果超出数组界限还没有找到累加器的初始值，则TypeError
    if (k >= len) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    accumulator = O[k++];
  }
  while (k < len) {
    if (k in O) {
      accumulator = callback.call(undefined, accumulator, O[k], k, O);
    }
    k++;
  }
  return accumulator;
}
```

## Function.prototype.apply()
---
第一个参数是绑定的this,默认为`window`,第二个参数是数组或类数组.
```js
Function.prototype.apply = function(context = window, args) {
  if (typeof this !== 'function') {
    throw new TypeError('Type Error');
  }
  const fn = Symbol('fn');
  context[fn] = this;

  const res = context[fn](...args);
  delete context[fn];
  return res;
}
```

## Function.prototype.call()
---
于`call`唯一不同的是,`call()`方法接受的是一个参数列表.
```js
Function.prototype.call = function(context = window, ...args) {
  if (typeof this !== 'function') {
    throw new TypeError('Type Error');
  }
  const fn = Symbol('fn');
  context[fn] = this;

  const res = context[fn](...args);
  delete context[fn];
  return res;
}
```

## Function.prototype.bind()
---

```js
Function.prototype.bind = function(context, ...args) {
  if (typeof this !== 'function') {
    throw new Error("Type Error");
  }
  // 保存this的值
  var self = this;

  return function F() {
    // 考虑new的情况
    if(this instanceof F) {
      return new self(...args, ...arguments)
    }
    return self.apply(context, [...args, ...arguments])
  }
}
```

## JSONP
---
前台定义待调用函数,后台返回调用该函数的代码.
```js
let jsonp = (url, params, callbackName) => {
    function generateUrl() {
        let dataSrc = '';
        for(let key in params) {
            if(Object.prototype.hasOwnProperty.call(params, key)) {
                dataSrc += `${key}=${params[key]}&`;
            }
        }
        dataSrc += `callbackName=${callbackName}`;
        return `${url}?${dataSrc}`;
    }

    return new Promise((resolve, reject) => {
        let scriptEle = document.createElement('script');
        let doc = document.documentElement || document.body;
        scriptEle.src = generateUrl();
        doc.appendChild(scriptEle)
        window[callbackName] = function(data) {
            resolve(data);
            doc.removeChild(scriptEle);
        }
    })
}
```

## 前端需要注意哪些 SEO
---

1. 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可
2. 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页
3. 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
4. 重要内容不要用 js 输出：爬虫不会执行 js 获取内容
5. 少用 iframe：搜索引擎不会抓取 iframe 中的内容
6. 非装饰性图片必须加 alt
7. 提高网站速度：网站速度是搜索引擎排序的一个重要指标

## css sprite 是什么,有什么优缺点
---
概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。
优点：
1. 减少 HTTP 请求数，极大地提高页面加载速度
2. 增加图片信息重复度，提高压缩比，减少图片大小
3. 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

缺点：
1. 图片合并麻烦
2. 维护麻烦，修改一个图片可能需要重新布局整个图片，样式

## display: none;与visibility: hidden;的区别
---
共同点：它们都能让元素不可见
区别：
1. `display:none;`会让元素完全从渲染树中消失，渲染的时候不占据任何空间；`visibility: hidden;`不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见。
2. `display: none;`是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；`visibility: hidden;`是继承属性，子孙节点由于继承了 hidden 而消失，通过设置`visibility: visible;`可以让子孙节点显示。
3. 修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘。
4. 读屏器不会读取`display: none;`元素内容；会读取`visibility: hidden;`元素内容。

## link与@import的区别
---
1. `link`是 HTML 方式， `@import`是 CSS 方式
2. `link`最大限度支持并行下载，`@import`过多嵌套导致串行下载，出现FOUC
3. `link`可以通过`rel="alternate stylesheet"`指定候选样式
4. 浏览器对`link`支持早于`@import`，可以使用`@import`对老浏览器隐藏样式
5. `@import`必须在样式规则之前，可以在css文件中引用其他文件
6. 总体来说：`link`优于`@import`

## 清理浮动
---

```css
.clearfix {
  *zoom: 1;
}
.clearfix::before, .clearfix::after {
  display: table;
  content: " ";
}
.clearfix::after {
  clear: both;
}
```
## 什么是 FOUC?如何避免
---
**Flash Of Unstyled Content**：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head.

## sessionStorage,localStorage,cookie 区别
---

1. 都会在浏览器端保存，有大小限制，同源限制
2. cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器
3. cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie
4. 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除
5. 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享
6. localStorage 的修改会促发其他文档窗口的 update 事件
7. cookie 有 secure 属性要求 HTTPS 传输
8. 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M

## javascript 跨域通信
---
同源：两个文档同源需满足
{% note info %}
1.协议相同;2.域名相同;3.端口相同
{% endnote %}
跨域通信：js 进行 DOM 操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法: 
1. 如果是 log 之类的简单单项通信，新建`<img>,<script>,<link>,<iframe>`元素，通过 src，href 属性设置为目标url。实现跨域请求
2. 如果请求json 数据，使用`<script>`进行`jsonp`请求
3. 现代浏览器中多窗口通信使用 HTML5 规范的 targetWindow.postMessage(data, origin);其中 data 是需要发送的对象，origin 是目标窗口的 origin。window.addEventListener('message', handler, false);handler 的 event.data 是 postMessage 发送来的数据，event.origin 是发送窗口的 origin，event.source 是发送消息的窗口引用
4. 内部服务器代理请求跨域 url，然后返回数据
5. 跨域请求数据，现代浏览器可使用 HTML5 规范的 CORS 功能，只要目标服务器返回 HTTP 头部**Access-Control-Allow-Origin: ***即可像普通 ajax 一样访问跨域资源

## javascript 有哪几种数据类型
---
六种基本数据类型:
`undefined null string boolean number symbol(ES6) BigInt(ES10)`
一种引用类型:
`Object`

## 什么闭包,闭包有什么用
---
闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分：
1. 函数本身作用域。
2. 闭包定义时的作用域。
3. 全局作用域。

闭包常见用途：
1. 创建特权方法用于访问控制
2. 事件处理程序及回调

## javascript 有哪几种方法定义函数
---

1. 函数声明(函数语句)

```js
function test(a) {
    console.log(a);
}
```
2. 函数表达式

```js
// 匿名函数
var myFunction = function() {
    // statements
}
// 也可以定义时为函数命名
var myFunction = function namedFunction(){
    // statements
}
```
3. 箭头函数表达式

```js
(a) => {
    console.log(a);
}
```
4. Function构造函数

```js
var multiply = new Function('x', 'y', 'return x * y');
```
## javascript 有哪些方法定义对象
---
对象字面量：`var obj = {}`;
构造函数： `var obj = new Object()`;
Object.create(): `var obj = Object.create(Object.prototype)`;

## ===运算符判断相等的流程是怎样的
---
如果两个值不是相同类型，它们不相等
如果两个值都是 null 或者都是 undefined，它们相等
如果两个值都是布尔类型 true 或者都是 false，它们相等
如果其中有一个是NaN，它们不相等
如果都是数值型并且数值相等，他们相等， -0 等于 0
如果他们都是字符串并且在相同位置包含相同的 16 位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和
===都认为他们不相等
如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等
## ==运算符判断相等的流程是怎样的
---
如果两个值类型相同，按照===比较方法进行比较
如果类型不同，使用如下规则进行比较
如果其中一个值是 null，另一个是 undefined，它们相等
如果一个值是数字另一个是字符串，将字符串转换为数字进行比较
如果有布尔类型，将true 转换为 1，false 转换为 0，然后用==规则继续比较
如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较
其他所有情况都认为不相等

## 相关链接

[收集的前端面试题和答案](https://github.com/qiu-deqing/FE-interview#html-httpweb-%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98)
[32个手写JS，巩固你的JS基础](https://juejin.cn/post/6875152247714480136#heading-42)
